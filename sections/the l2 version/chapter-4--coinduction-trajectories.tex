
%==============================
\chapter{Trajectories by Coinduction}
\label{chap:journey-of-a-Sign}
%==============================

\section{Orientation: from frame calculus to life by coinduction}

The calculus of Chapter~3 provides a powerful, frame-by-frame account of meaning in motion. With the constructors for \emph{drift}, \emph{rupture}, and \emph{heal}, we can certify the validity of a single step a term takes from one moment in time~$\tau$ to the next~$\tau'$. This gives us a logic of local dynamics, a way to audit the microscopic movements of sense.

However, a single step does not make a journey. Our intuition about meaning---and especially about the identity of any recurring sign---is not based on isolated snapshots. It is based on the perception of an enduring entity that maintains its coherence through a sequence of such steps. Chapter~3 tells us that a term can survive a cut in time, but it does not by itself give us a \emph{single} mathematical object that represents the term's entire life across many such cuts.

This chapter lifts frames to \enquote{life}. We show that a term's persistence is best understood not as a static denotation, but as a \emph{coinductive trajectory}. Coinduction is the natural logic of processes and behaviours; its \emph{guarded} variant is perfectly suited to the step-by-step, temporal nature of discourse. By defining term-trajectories as elements of a final coalgebra, we can package the frame-by-frame moves of Chapter~3 into a unified object that represents the life of a sign.

\bigskip

\noindent\textbf{Roadmap.} We proceed in layers. \S\ref{sec:coinduction-corecursion} introduces coinduction and corecursion abstractly, via coalgebras and final coalgebras, together with the bisimulation principle. \S\ref{sec:guarded-clocked} specialises this to our temporal semantics by introducing the \emph{Later} modality~$\Later$ and guarded coinduction in a clocked presheaf model. Only then, in \S\ref{sec:step-functor}, do we instantiate the general theory with a \emph{step functor} that packages one justified advance. Finally, \S\ref{sec:depth-bisim}, \S\ref{sec:micro-examples}, and \S\ref{sec:philo-bridge} connect back to the rupture--repair calculus, work through minimal examples, and draw out the philosophical takeaway.

%--------------------------------------------
\section{Coinduction, corecursion, and coalgebras}\label{sec:coinduction-corecursion}
%--------------------------------------------

Coinduction is the mathematics of \emph{observable continuations}. Where induction builds finite data bottom-up, coinduction \emph{unfolds} potentially infinite behaviour top-down: an element is known by what it reveals \emph{now} and how it promises to continue \emph{later}. Category theory packages this idea in terms of coalgebras.

\begin{definition}[Coalgebra and morphism]\label{def:coalgebra}
Let $F\colon \mathcal{C}\to \mathcal{C}$ be an endofunctor on a category~$\mathcal{C}$. An \emph{$F$-coalgebra} is a pair $(X,\gamma)$ with $X$ an object and $\gamma\colon X\to F X$ a structure map. A \emph{coalgebra morphism} $h\colon (X,\gamma)\to (Y,\delta)$ is a morphism $h\colon X\to Y$ with $Fh\circ \gamma = \delta\circ h$.
\end{definition}

\begin{definition}[Final coalgebra and coinduction]\label{def:final-coalgebra}
A \emph{final $F$-coalgebra} is a coalgebra $(\nu F, \unfold)$ such that for every coalgebra $(X,\gamma)$ there is a unique morphism $h\colon X\to \nu F$ with $\unfold\circ h = Fh\circ \gamma$. We write $\nu F$ for the carrier of a chosen final coalgebra and call it the \emph{coinductive type} generated by~$F$. The unique map $h$ is the \emph{coiteration} (or \emph{corecursion}) induced by~$\gamma$.
\end{definition}

Intuitively, $\unfold\colon \nu F\to F(\nu F)$ is the universal \emph{unfolding}: it reveals one observable layer of a behaviour in~$\nu F$. Dually, a map $\gamma\colon X\to F X$ is a \emph{specification of how an $X$-state steps}, and its coiteration $h\colon X\to \nu F$ \emph{runs} that specification to produce a behaviour.

\paragraph{Examples.}
\begin{itemize}
  \item For $F(X)=A\times X$ in $\Set$, the final coalgebra $\nu F$ is the type of \emph{streams} of $A$-values. The unfolding $\unfold(s)=(\mathsf{head}(s),\mathsf{tail}(s))$ returns the current observation and the continuation.
  \item For $F(X)=\mathcal{P}(L\times X)$ (finite powerset), $\nu F$ captures finitely branching \emph{labelled transition systems}; $\unfold$ exposes the set of enabled labelled moves and their continuations.
\end{itemize}

\paragraph{Bisimulation and proof by coinduction.}
Equality in a final coalgebra is governed by \emph{bisimulation}: two behaviours are equal when they can be matched step for step, forever.

\begin{definition}[Bisimulation]\label{def:bisim}
Given $F$ and coalgebras $(X,\gamma)$, $(Y,\delta)$, a relation $R\subseteq X\times Y$ is a \emph{bisimulation} if there exists $\rho\colon R\to F R$ such that the projections $\pi_1\colon R\to X$ and $\pi_2\colon R\to Y$ are coalgebra morphisms $(R,\rho)\to (X,\gamma)$ and $(R,\rho)\to (Y,\delta)$. When $X=Y=\nu F$ and $\gamma=\delta=\unfold$, we write $x\mathrel{R}y$ and say $x$ and $y$ are \emph{bisimilar}.
\end{definition}


To prove $x=y$ in a final coalgebra $(\nu F,\unfold)$, it suffices to exhibit a bisimulation $R$ on $\nu F$ with $x \mathrel{R} y$.

\paragraph{Corecursion (building elements).}
Dually, to \emph{construct} an element of $\nu F$, it suffices to provide a coalgebra structure $\gamma\colon X\to F X$ together with a seed $x_0\in X$ and then define $x\coloneqq \mathsf{coit}(\gamma)(x_0)\in \nu F$. In type theory, this is the \emph{introduction rule} for coinductive types, often written as a \emph{corecursor}. The \emph{eliminator} is the unfolding map $\unfold$.

\medskip

The rest of this chapter specialises these general ideas to our temporal semantics, where the functors of interest are not arbitrary: they must be \emph{guarded} by time.

%--------------------------------------------
\section{Guarded coinduction in a clocked presheaf model}\label{sec:guarded-clocked}
%--------------------------------------------

We continue to work within the space of the meaning of evoling texts, $\DynSem Sem$

\paragraph{The Later modality.}
Guarded coinduction uses a \emph{Later} modality~$\Later$ that shifts observation one tick into the future. Semantically, $\Later\colon \DynSem \to \DynSem $ is given by precomposition with a \emph{successor} endofunctor on~$\mathbb{T}$; syntactically, we write $\Later X$ for \enquote{an $X$ available later}. Guardedness enforces \emph{productivity}: recursive occurrences must be protected by~$\Later$, preventing paradoxical definitions that try to inspect an entire infinite future at once.

%========================================================
\section{Guarded coinduction (rules)}
\label{subsec:guarded-rules}
%========================================================

We interpret types in the clocked presheaf topos, where the “later” modality
\(\Later\) is a one‑step clock shift. A guarded endofunctor \(F\) (every
occurrence of its argument appears strictly under \(\Later\)) admits a final
coalgebra \(\nu X.F(X)\) with structure map
\(\unfold : \nu X.F(X) \to F\bigl(\nu X.F(X)\bigr)\). % FIX: removed spurious \Later
The internal language of this model is DHoTT with corecursion, now defined. 

The rules below
are just the internalization of:
\begin{enumerate}
\item existence of \(\nu X.F(X)\) for guarded \(F\),
\item its destructor \(\unfold\) (elimination), and
\item the universal property (introduction as a unique coalgebra morphism).
\end{enumerate}
We write \(\Gamma \vdash_{\tau} t : A\) for typing judgments at a fixed clock
\(\tau\) (we usually suppress \(\tau\) when irrelevant). We also write
\(\Next_A : A \to \Later A\) for the canonical introduction of \(\Later\).

\subsection{The \texorpdfstring{\(\Later\)}{Later} modality (spelled out)}
We record the basic rules for \(\Later\) used implicitly by the guarded
coinduction rules. These are precisely the rules validated by the clock‑shift
semantics; no general elimination that “removes” \(\Later\) is admissible.

\begin{mathpar}
\inferrule
  { \Gamma \vdash_{\tau} A : \mathcal{U} }
  { \Gamma \vdash_{\tau} \Later A : \mathcal{U} }
    \quad \Later\textsc{-Form}
\and
\inferrule
  { \Gamma \vdash_{\tau} t : A }
  { \Gamma \vdash_{\tau} \Next_A(t) : \Later A }
  \quad \Later\textsc{-Intro}
\end{mathpar}

\paragraph{Guarded elimination (applicative/let‑later).}
Elimination is only allowed under a further \(\Later\). We use either of the
following interderivable forms.
\[
\inferrule
  { \Gamma \vdash_{\tau} u : \Later A
    \quad
    \Gamma, x:A \vdash_{\tau} t : \Later B }
  { \Gamma \vdash_{\tau} \mathbf{let}  x \Leftarrow u  \mathbf{in}  t : \Later B } \quad \Later\textsc{-Elim}
\qquad
\inferrule
  { \Gamma \vdash_{\tau} f : \Later(A\to B)
    \quad
    \Gamma \vdash_{\tau} u : \Later A }
  { \Gamma \vdash_{\tau} f  \mathsf{ap}  u : \Later B }
    \quad \Later\textsc{-Ap}
\] 
The equations
\(
\mathbf{let}  x \Leftarrow \Next(t)  \mathbf{in}  u  \equiv  u[t/x]
\)
and the usual (applicative) functor laws for \(\Later\) hold definitionally.

\medskip

\subsection{Guarded greatest fixed points}
We now give the rules for guarded \(\nu\), making the guardedness side condition
explicit.

\begin{mathpar}
\inferrule
  { \Gamma, X:\mathcal{U} \vdash_{\tau} F(X) : \mathcal{U}
    \quad
    \text{\(X\) occurs only under \(\Later\) in \(F(X)\)} }
  { \Gamma \vdash_{\tau} \nu X. F(X) : \mathcal{U} }
  \quad \textsc{Guarded-\(\nu\)-Form}
\end{mathpar}

\begin{mathpar}
\inferrule 
  { \Gamma, x:\Later \bigl(\nu X. F(X)\bigr) \vdash_{\tau} t : F \bigl(\nu X. F(X)\bigr) }
  { \Gamma \vdash_{\tau} \gcorec(x. t) : \nu X. F(X) }
  \quad \textsc{Guarded-\(\nu\)-Intro}
\end{mathpar}

\begin{mathpar}
\inferrule
  { \Gamma \vdash_{\tau} u : \nu X. F(X) }
  { \Gamma \vdash_{\tau} \unfold(u) : F \bigl(\nu X. F(X)\bigr) } % FIX: removed \Later here
  \quad \textsc{Guarded-\(\nu\)-Elim}
\end{mathpar}

\paragraph{Computation and extensionality.}
Unfolding a guarded corecursive definition exposes precisely the guard it was
defined with:
\[
  \unfold\bigl(\gcorec(x. t)\bigr)
   \equiv 
  t\bigl[ \Next_{\nu X. F(X)}\bigl(\gcorec(x. t)\bigr) / x \bigr]
  \quad\text{(\(\beta\)-law).}
\]
Conversely, every \(u : \nu X. F(X)\) is \emph{bisimilar} to the corecursive
term that re‑folds its own unfolding:
\[
  u  \approx  \gcorec \bigl(x. \tilde{t}\bigr)
  \quad\text{where}\quad
  \tilde{t}   :=   \unfold(u)   . % FIX: drop redundant F(\mathsf{id})
\]
(an \(\eta\)-principle up to the bisimulation for \(\Traj(A)\) introduced
below). \emph{Uniqueness up to bisimilarity} is precisely the internal form of
finality of \(\nu\).

\emph{Why guardedness?} The clock shift \(\Later\) strictly decreases the time
index; requiring \(X\) to occur only under \(\Later\) ensures productivity and
makes \(F\) contractive, yielding a final coalgebra.

\emph{Why these sequents?} \textsc{Intro} is the coiteration principle with a
guarded recursive argument \(x:\Later(\nu F)\). \textsc{Elim} is the structure
map \(\unfold : \nu F \to F(\nu F)\). The \(\beta\)-law is the
coalgebra‑morphism equation; the \(\eta\)-principle is finality.



\paragraph{User's manual (operational reading).}
Induction builds from the bottom up; coinduction streams from the top down.
To \emph{build} $x : \nu X. F(X)$, provide one certified observation
$t : F(\nu X. F(X))$ whose self-uses are deferred by $\Later$—intuitively:
“\emph{one step, and a promise to continue later}.”
To \emph{observe} $x$, call the destructor $\unfold(x):F(\nu X. F(X))$:
you may see exactly one step now, and only a guarded tail beyond.

\paragraph{Working with \(\Later\).}
Elimination for \(\Later\) is only allowed under an additional \(\Later\)
(e.g. via an applicative ``let‑later''): from \(u:\Later A\) and
a continuation \(x : A \vdash t:\Later B\) we may form
\(\mathbf{let}  x \Leftarrow u  \mathbf{in}  t : \Later B\).
Intuitively: you can only use a ``later'' value at a later time.



\begin{theorem}[Final coalgebras for guarded polynomial functors]\label{thm:final-coalg-guarded}
In $\DynSem $, every \emph{guarded polynomial} functor $F$ admits a final coalgebra $(\nu F,\unfold)$. Moreover, $\unfold$ and the corecursor satisfy their computation laws strictly and fibrewise: for each time $\tau$, the component $(\nu F)(\tau)$ is computed from the components of~$F$ at~$\tau$.
\end{theorem}

\noindent The theorem secures the existence and well-behavedness of the coinductive types we use. In practice, we design $F$ so that guardedness is evident by inspection: recursive occurrences sit to the right of~$\Later$.

%--------------------------------------------
%--------------------------------------------
\section{From guarded functors to trajectories: the step functor}\label{sec:step-functor}

With the general machinery in place, we can now package the evolution of a
justified inhabitation (a constructive witness, in the sense of the
drift/rupture/repair calculus of Chapter~3) of a family $A(\tau)$
into a single type-theoretic object.
The idea is to focus on one \emph{justified advance} at a time:
a move from $a\in A(\tau)$ to $a'\in A(\tau')$,
certified by a witness, together with a guarded promise to continue.
This packaging is the role of the \emph{step functor},
which captures a single observable move and its continuation handle.
%--------------------------------------------
%--------------------------------------------
\subsection{From one step to the step functor}
%--------------------------------------------
\paragraph{Step witnesses.}
The frame calculus of Chapter~3 told us, for each edit $e:\tau\leadsto\tau'$,
how a current inhabitant $a\in A(\tau)$ may continue as some
$a'\in A(\tau')$: either by \emph{drift}, or by \emph{rupture} repaired
with a \emph{heal} or a \emph{reconcile}.
We now gather those cases into a single type family.
\[
  \Step_A(\tau,\tau';a,a')
\]
is the type of \emph{certificates} that $a$ at time $\tau$
legitimately continues as $a'$ at time $\tau'$.
Its constructors are exactly those of the Chapter~3 calculus:
\begin{itemize}
  \item $\mathsf{transport}$ for a drift with no repair,
  \item $\mathsf{heal}(\rho)$ for a rupture repaired at depth $1$,
  \item $\mathsf{reconcile}(\kappa)$ for a rupture reconciled at depth $2$.
\end{itemize}
Inhabitants of $\Step_A(\tau,\tau';a,a')$ are thus constructive
\emph{proofs of continuation}: they witness that the evolving family
$A(-)$ remains legitimately inhabited across a tick of the clock.

\paragraph{Nothing mysterious about \(\Later\).}
In Chapter~3 the tick $\tau\leadsto\tau'$ was always explicit.
The new symbol $\Later$ is just a way of \emph{internalising} that tick
into the type system. Writing $\Later X$ means “an $X$ one step later.”
So when we unfold a trajectory we still see exactly the same data as before
---a current exposure $a$, an edit $e:\tau\leadsto\tau'$, a next $a'$,
and a step-witness $\rho$---together with a \emph{guarded tail}
$\Later x$ which promises that the life continues at the next tick.

\begin{definition}[Step functor $F_A$]\label{def:step-functor}
Fix a time-varying type family $A$.
Define the endofunctor
\[
  F_A(X)  \coloneqq 
    \sum_{a\in A(\tau)} 
    \sum_{e:\tau\leadsto\tau'} 
    \sum_{a'\in A(\tau')} 
    \Step_A(\tau,\tau';a,a')
     \times  \Later X .
\]
An element of $F_A(X)$ is a single justified advance:
a tuple $(a,e,a',\rho,\Later x)$ with
$a:A(\tau)$, $e:\tau\leadsto\tau'$, $a':A(\tau')$,
$\rho:\Step_A(\tau,\tau';a,a')$, and a guarded continuation $x:X$.
\end{definition}

\paragraph{Categorical reading.}
Here we move from type theory to semantics.
The family $F_A$ is a \emph{guarded polynomial functor}
in the clocked presheaf topos.
Because the recursive occurrence $X$ sits strictly under~$\Later$,
$F_A$ is contractive, and by Theorem~\ref{thm:final-coalg-guarded}
it admits a final coalgebra.
That coalgebra is the type of \emph{trajectories}:
\[
  \Traj(A)  \coloneqq  \nu F_A.
\]
So the fancy-pants categorical language is not extra decoration:
it guarantees that our constructive packaging of steps into lives
is sound and comes with a built-in proof principle (bisimulation).



\begin{definition}[Step functor $F_A$]\label{def:step-functor}
Fix a time-varying type family $A$ (a fibre over time). Define the endofunctor
\[
  F_A(X)  \coloneqq  \sum_{a\in A(\tau)}\ \sum_{e:\tau\leadsto\tau'}\ \sum_{a'\in A(\tau')}\ \Step_A(\tau,\tau';a,a')\ \times\ \Later X.
\]
Its elements record: a current exposure $a$, an edit $e\colon\tau\leadsto\tau'$, a next exposure $a'$, a witness $\rho\in \Step_A(\tau,\tau';a,a')$ justifying the transition, and a guarded tail in~$X$.
\end{definition}

Guardedness is explicit: the recursive occurrence $X$ sits to the right of~$\Later$. We may therefore form the coinductive type generated by~$F_A$.

\begin{definition}[Trajectory type]\label{def:trajectory-type}
The \emph{trajectory type} over~$A$ is the final coalgebra of the step functor:
\[
  \Traj(A)  \coloneqq  \nu F_A.
\]
An inhabitant $x:\Traj(A)$ is a persistent process that can be unfolded into its current observation $(a,e,a',\rho)$ and a guarded tail $x^\sharp:\Later \Traj(A)$.
\end{definition}

\paragraph{Corecursion and unfolding.} The corecursor for $\Traj(A)$ is exactly the \enquote{give me one step and a later continuation} pattern, while $\unfold:\Traj(A)\to F_A(\Traj(A))$ reveals the current step and the promise to continue. The computation law~$\unfold(\mathsf{wrap}(t))=t$ is the bookkeeping identity ensuring that unfolding a freshly built step returns what we just said would happen.



\paragraph{Bisimulation for trajectory equality.} How do we know if two trajectories represent the \enquote{same life}? Coinduction provides the natural answer: two trajectories are equal when their one-step unfoldings agree and their (guarded) tails are again equal. Formally, we reason by bisimulation in the final coalgebra $(\Traj(A),\unfold)$ via Principle~\ref{princ:coinduction}.


%--------------------------------------------
\section{Interaction with repair: depth along a coinductive life}
\label{sec:depth-bisim}
%--------------------------------------------

The coinductive unfolding of a life exposes, at every cut $\tau\leadsto\tau_1$,
a \emph{step witness} $\rho$ drawn from the same proof-relevant kit introduced
in Chapter~3: transport (Drift), rupture with a stitch $\heal$ (Depth~1), and
reconciliation $\kappa$ between two stitches (Depth~2). In Chapter~4 these
witnesses are now carried inside the coalgebraic structure (the one-step
unfolding), so that a trajectory records not only \emph{that} it continued but
\emph{how} coherence was earned at each slice.

\begin{definition}[Depth of repair]\label{def:depth-of-repair}
Let $\rho\in \Step_A(\tau,\tau_1; a,a')$ be the step witness in the unfolding
$\unfold(x)=(a,e,a',\rho,\Later x_1)$. The \emph{depth of repair} $\depth(\rho)$ is
\[
\depth(\rho) :=
\begin{cases}
0 & \text{if $\rho$ arises by (frame-internal) transport,}\\
n\ge 1 & \text{if $\rho$ adjoins a minimal $n$-simplex in a rupture type
(as in \S3.8),}
\end{cases}
\]
i.e.\ the minimal horn dimension needed to keep reasoning lawful at~$\tau_1$.
Thus unfolding a trajectory reveals both its states and the \emph{dimensional cost}
of maintaining coherence between them.
\end{definition}

\begin{lemma}[Locality of depth]\label{lem:depth-local}
If $\unfold(x)=(a,e,a',\rho,\Later x_1)$, then $\depth(\rho)$ depends only on
data at the cut $\tau\leadsto\tau_1$; it is independent of the tail $x_1$.
\emph{Sketch.} In \S3.8 rupture is formed \emph{in the later slice}, and the stitch
$\heal$ (or a reconciliation $\kappa$) lives in the same slice. Depth is therefore
computed in the fibre at $\tau_1$ (pushout + identity tower), with no reference to
future unfoldings. \qed
\end{lemma}

\begin{proposition}[Prefix stability]\label{prop:prefix-stability}
Let $\rho_0,\dots,\rho_{N-1}$ be the first $N$ step witnesses of $x$. Then for
aggregates such as
\[
\Maxdepth(N)=\max_{i<N} \depth(\rho_i)
\qquad \text{and} \qquad
\mathrm{incidence}_{\ge k}(N)=\frac{|\{ i<N \mid \depth(\rho_i)\ge k \}|}{N}
\]
the update from $N$ to $N{+}1$ depends only on $\rho_{N}$.
\emph{Sketch.} By Lemma~\ref{lem:depth-local}, $\depth(\rho_N)$ is determined at
the $N$-th cut. The functionals above are prefix-monotone summaries, hence their
increment depends only on $\depth(\rho_N)$. \qed
\end{proposition}

\subsection{Rupture as horn failure (and how the SWL detects triangles)}
\label{subsec:horns-and-swl}

\paragraph{Simplicial reading (frame-internal).}
Fix $\tau$ and read the fibre $A(\tau)$ as a Kan complex (HoTT space).
Chapter~3 showed that when transport cannot be exhibited across a cut, we
\emph{form} a rupture type $\Rupt_p(a)@{\tau_1}$ and \emph{adjoin} the minimal
cell that licenses continuation in the later slice (see \S3.8: \textsc{Rupture-Form},
\textsc{Rupt-Elim}). In simplicial terms:

\begin{center}
\begin{tabular}{rcl}
depth $0$ & $\leadsto$ & transport only (no horn missing);\\
depth $1$ & $\leadsto$ & adjoin a $1$-simplex (a path $\heal$: stitch / ``heal'');\\
depth $2$ & $\leadsto$ & adjoin a $2$-simplex (a homotopy $\kappa$: reconcile two stitches);\\
depth $3$ & $\leadsto$ & adjoin a $3$-simplex (coherence between reconciliations);\\
$\vdots$ & & \\
\end{tabular}
\end{center}

This is precisely the higher-dimensional counterpart of
Def.~\ref{def:depth-of-repair}: the \emph{depth} carried by each step witness is the
dimension of the simplex that had to be adjoined in the later slice to keep going.
In coalgebraic language, the unfolding records that choice as $\rho$ for the step
$(a \leadsto a')$; the trajectory’s life is the guarded chaining of such choices.

\paragraph{Operational bridge (SWL).}
The Step–Witness Log of Chapter~5 mirrors the same structure at observational
grain: \emph{transport} $\leftrightarrow$ depth~0; \emph{heal} $\leftrightarrow$ depth~1
(single decisive target in the later slice); \emph{reconcile} $\leftrightarrow$ depth~2
(two near-maximal targets with a recorded compatibility). Thus SWL “triangle”
events are empirical 2-horns whose fillers correspond to the $\kappa$-witness in
$\Rupt_p(a)$; higher interlocking reconciliations surface as candidate 3-horns.

\paragraph{Remark (continuity with Chapter~3).}
Nothing essentially new is added to the \emph{frame} calculus: transport, rupture,
stitch, and reconciliation remain as in \S3.8. Chapter~4 reframes them
coalgebraically: the \emph{same} proof-objects now constitute the one-step payload
of a final coalgebra (guarded by $\Later$), so that a “life” is a coinductively
witnessed sequence of lawful continuations with a depth ledger.


\paragraph{Soundness (fibrancy under repair).}
Because point inclusions are cofibrations in $\mathbf{SSet}$ and pushouts along
cofibrations compute homotopy pushouts, adjoining an $n$-simplex (of any finite $n$)
preserves Kan fibrancy up to fibrant replacement; trajectories thus remain Kan after
repairs (cf.\ our fibrancy lemmas in the fibre model).\footnote{We use the same
left-properness/fibrancy facts as in the rupture semantics of Ch. 3; see the
Kan/Quillen discussion there.}

\paragraph{Practice meets theory: SWL as empirical horn detection.}
The Step–Witness Log (SWL) from Ch. 5 already implements \emph{empirical} detection of
low-dimensional horn situations at each cut $\tau \leadsto \tau'$. In particular:

\begin{description}
\item[Depth 1 (missing edge).] The SWL records \texttt{witness\_tag = heal, depth = 1}
when transport fails but a \emph{single} target is decisively best in the later slice.
This is the $1$-horn fill case (we adjoin a path). See the ``Heal branch (depth 1)''
rule in §5.3. :contentReference[oaicite:0]{index=0}

\item[Depth 2 (missing triangle).] The SWL records \texttt{witness\_tag = reconcile,
depth = 2} exactly when transport fails and the top two candidates in the target slice
are in a near-tie ($m \le \varepsilon_{\text{tie}}$). The ledger anchors at $j_1$,
\emph{records the runner-up $j_2$}, and attaches a certificate $\kappa$; this is an
\emph{empirical 2-simplex} witnessing that two admissible repair paths cohere
locally---a filled $2$-horn. See the ``Reconcile branch (depth 2)'' and the
recommended fields (\texttt{tgt\_j1, tgt\_j2, tgt\_margin, alt\_candidates}) in §5.3. :contentReference[oaicite:1]{index=1}

\item[Depth 3 (coherence of reconciliations).] When two adjacent steps are both
\texttt{reconcile} and \emph{share an edge} (e.g.\ $j_1 \leftrightarrow j_2$ at $\tau \leadsto \tau'$
and $j_2 \leftrightarrow j_3$ at $\tau' \leadsto \tau''$), we empirically witness
a $3$-horn shape. A depth-3 repair is precisely the tetrahedral filler showing the two
local triangles cohere. We can flag this pattern in the SWL without new constructors
(\S\ref{subsec:horns-and-swl}/\emph{Empirical depth-3 flag} below), deferring any explicit
higher constructor to later chapters. The vignettes already hint at such motifs
(e.g.\ interlocking reconciles around transient register shifts). :contentReference[oaicite:2]{index=2}
\end{description}

\paragraph{Empirical depth-2 (triangle) claim.}
Each SWL row with \texttt{witness\_tag = reconcile, depth = 2} constitutes an empirical
certificate of a \emph{filled 2-horn} in the later slice: two near-maximal repair paths
are recorded (best $j_1$ and runner-up $j_2$), and the $\kappa$ field witnesses the local
compatibility of these paths. This is exactly the simplicial reading of a missing
triangle that is then adjoined. See §5.3 (algorithm and fields) and the worked
vignettes in §5.5. 

\paragraph{Empirical depth-3 (coherence) flag (pattern over two cuts).}
Without changing the calculus, one can define a \emph{flag} on the SWL that marks
candidate $3$-horns: whenever two consecutive steps for the same head are both
\texttt{reconcile} and share a basin edge, emit \texttt{coh\_3\_flag = true}. This is an
observational statement: ``two filled triangles share a face; a $3$-simplex would make
their reconciliations cohere.'' The operational calculus may still truncate at depth $\le 2$
(Ch. 5), but the theory in this section explains what such a flag \emph{means}.




\paragraph{How to use it.}
To prove \(x=y\) in \(\Traj(A)\), relate their unfoldings now
(and show the witness tags match in the appropriate fibres),
then relate the guarded tails again; coinduction discharges the infinite rest.

%--------------------------------------------
\section{A Sign's Life: Worked Examples from the Lion Passage}
\label{sec:micro-examples}
%--------------------------------------------

We return to the dialogue from Chapter~3, where a conversation about a lion pivots from the zoological to the theological. This allows us to animate the calculus of Chapter~3 with the coinductive machinery of this chapter.

Let's begin by anchoring our formal language to the intuitive concepts. The reader sees the string of letters ``lion'' on the page; we call this a \emph{token}. But the object we track is the \emph{sign}: the token as it is realized in the dialogue, carrying a specific sense. In our logic, this correspondence is precise: a sign is a term, and its currently available field of sense is its type.

Crucially, a type in DHoTT is not a static box. We model it as a type family (or, more formally, a presheaf) over time, which we will write as $A$. This means that for each moment $\tau$, the type family gives us a specific fibre, $A(\tau)$, which is the HoTT space of available senses for ``lion'' at that moment. As the dialogue unfolds, the very space of sense can change. The life of the sign ``lion'' is therefore its trajectory, a single coinductive object, $\Traj(A)$, whose history we can inspect one step at a time using the unfold operation. The unfolding is a receipt: it reveals where the sign was, where it went, and the proof-relevant witness that licensed the move.

\paragraph{Depth 0: Coherent Drift.}
Initially, the dialogue is stable. The sense of ``lion'' is zoological. Its type, which we can call \textsf{ZoologicalLion}, persists across time slices $\tau$ and $\tau'$. The unfolding of the trajectory $t_{\mathsf{lit}}$ shows the term (the sign) \emph{lion} being lawfully transported from an inhabitant of \textsf{ZoologicalLion} at $\tau$ to another inhabitant of the same type at $\tau'$:
\[
  \unfold(t_{\mathsf{lit}}) \mapsto 
  \left(\text{lion}_{\mathsf{lit}}, e, \text{lion}_{\mathsf{lit}}, \mathsf{transport}, \Later t'_{\mathsf{lit}}\right).
\]
The receipt is simple: the sign began as a literal lion, and after the edit $e$, it remains a literal lion. The witness is $\mathsf{transport}$, confirming the sign's sense has not ruptured. The Step-Witness Log (SWL) records this low-cost continuation: \texttt{witness\_tag=transport}, \texttt{depth=0}.

\paragraph{Depth 1: Rupture and a Single Stitch.}
The human speaker then introduces a new register, rupturing the established sense. The old type, \textsf{ZoologicalLion}, is no longer adequate to classify the sign. DHoTT responds not with an error, but by constructing a new, richer space of sense: the rupture type $\Rupt_{p}(\text{lion})@{\tau_1}$, which is formed in the later time slice. This new type is built to contain both the new meaning and the memory of the old. It has its own distinct terms:
\begin{itemize}
  \item $\tear(\text{lion})$: the new, re-typed sign, which now has the sense of the christological title, \textsf{LionOfJudah}. This is where the thread re-anchors in the new theological context.
  \item $\dtr_{p}(\text{lion})$: the ``echo'' of the old term. It represents the zoological sense, now present only as a phantom or a point of comparison within this new type.
  \item $\heal(\text{lion})$: the crucial proof object—a path that stitches the two terms together inside the new rupture type. It witnesses the legitimacy of the metaphorical leap.
\end{itemize}
The unfolding of the trajectory now exposes this entire repair structure as its witness:
\[
  \unfold(t_{\heartsuit}) \mapsto 
  \left(\text{lion}_{\mathsf{lit}}, e, \text{LionOfJudah}, \heal(\text{lion}), \Later t'_{\heartsuit}\right).
\]
The trajectory advances from a term of one type to a term of another, and the move is licensed by the proof object $\heal(\text{lion})$. This is a depth-1 repair, which geometrically adjoins a $1$-simplex (the healing path) to the space of sense. The SWL entry is decisive: \texttt{witness\_tag=heal}, \texttt{depth=1}.

\paragraph{Depth 2: Reconciling Competing Senses.}
A rupture can open a space of multiple plausible new senses. Suppose the context is ambiguous: the sign ``lion'' could be re-typed as \textsf{LionOfJudah}, but it could also be interpreted as a more generic \textsf{KinglySymbol}. Both are admissible repairs, meaning two distinct healing paths, $h_{\mathsf{judah}}$ and $h_{\mathsf{regal}}$, are available as terms within the rupture type.

To proceed with a single coherent narrative, we must show that these two repairs—these two different ways of making sense—are themselves compatible. This requires a depth-2 witness: a reconciliation $\kappa$, which is a path between the two healing paths (a 2-cell):
\[
  \kappa : \Id \left(h_{\mathsf{judah}}, h_{\mathsf{regal}}\right).
\]
The unfolding now records this higher-dimensional act of sense-making. The witness is not just a single path, but the entire structure of two paths and their reconciliation:
\[
  \unfold(t_{\mathsf{rec}}) \mapsto 
  \left(\text{lion}_{\mathsf{lit}}, e, \text{LionOfJudah}, 
  \mathsf{reconcile}\langle h_{\mathsf{judah}},h_{\mathsf{regal}},\kappa\rangle, 
  \Later t'_{\mathsf{rec}}\right).
\]
This depth-2 move enriches the type by adjoining a 2-simplex, certifying a productive ambiguity. The SWL records it as: \texttt{witness\_tag=reconcile}, \texttt{depth=2}.

\paragraph{The Coinductive Payoff.}
This coalgebraic perspective gives us a single mathematical object, $\Traj(A)$, for the entire life of a sign. The unfolding doesn't just show a sequence of states; it reveals the proof-relevant history of how the sign's sense (its type) was maintained, ruptured, and repaired over time. Each step—transport, heal, or reconcile—appears as the payload $\rho$ in the unfolding. The life of the sign ``lion'' becomes a guarded, corecursive stream of these receipts, providing us with a formal object that is also an auditable ledger of the dimensional cost of maintaining coherence.

%--------------------------------------------
\section{Philosophical takeaway and bridge}\label{sec:philo-bridge}
%--------------------------------------------

We began with the observation that the rupture--repair calculus of Chapter~3, while dynamic, is essentially \emph{microscopic}: it speaks in single frames. Guarded coinduction provides the missing macroscopic object. A trajectory is a single entity whose identity is constituted by its justified unfolding, one guarded step at a time. The Kan geometry of fibres says coherence \emph{can} be constructed; the calculus records \emph{when} it was constructed (depth) and \emph{how} it was earned (the witness tag).

From here, the rest of the book specialises this general construction. Chapter~5 instantiates $A$ as the empirical fibre for \emph{signs} in dialogue, equipped with a geography of basins and a structured halo, and shows how trajectories are made \emph{auditable} via the Step--Witness Log. Later chapters lift from trajectories to higher simplices, ultimately assembling coherent Selves.

% End of Chapter 4












